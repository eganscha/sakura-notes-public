<?php

namespace App\Models;

use http\Exception\RuntimeException;
use Illuminate\Support\Facades\Redis;
use Illuminate\Support\Str;
use InvalidArgumentException;
use Illuminate\Support\Facades;
use JsonSerializable;

class NoteModel implements JsonSerializable
{
    public const LARAVEL_KEY_PREFIX = 'note:'; // For storage inside the Laravel-DB: note:{id}
    private string $id;         // UUID generated by Laravel
    private string $email;      // email; (SELF IS QUERYABLE BY THIS!)
    private string $content;    // content of the note itself
    private array $tags;        // tags associated with that note; (SELF IS QUERYABLE BY THIS!)

    public function __construct(string $id, string $email, string $content, array $tags)
    {
        $this->id = $id;
        $this->email = $email;
        $this->content = $content;
        $this->tags = $tags;
    }

    public function jsonSerialize(): array
    {
        return [
            'id' => $this->id,
            'email' => $this->email,
            'content' => $this->content,
            'tags' => $this->tags,
        ];
    }

    public function getId(): string
    {
        return $this->id;
    }

    public function getEmail(): string
    {
        return $this->email;
    }

    public function getContent(): string
    {
        return $this->content;
    }

    public function getTags(): array
    {
        return $this->tags;
    }

    /**
     * 'Finds' a single note in the redis-db based on the provided note-id or null if no valid one was found
     */
    public static function find(string $id) : NoteModel
    {
        // Retrieves a note as a JSON Object from the Redis-DB
        $json = Redis::get(self::LARAVEL_KEY_PREFIX.$id);
        if($json === null) {
            throw new InvalidArgumentException("Note not found with id: $id");
        }

        // Decodes the JSON-String into an associative-array (Essentially a Key-Value Structure)
        // See: https://www.php.net/manual/en/function.json-decode.php
        $data = json_decode($json, true, flags: JSON_THROW_ON_ERROR);

        // Ensure that the decoded data is in the expected format
        if( !isset($data['id'])         ||  !is_string($data['id'])         ||
            !isset($data['email'])      ||  !is_string($data['email'])      ||
            !isset($data['content'])    ||  !is_string($data['content'])    ||
            !isset($data['tags'])       ||  !is_array($data['tags']))
        {
            throw new InvalidArgumentException("Decoded json data was not the expected format.\nInside of: NoteModel find(\$id)");
        }

        // return a note based on the data inside the associative-array
        return new NoteModel(
            $data['id'],
            $data['email'],
            $data['content'],
            $data['tags']
        );
    }

    public static function createAndStore(string $email, string $content, array $tags = ['NONE']) : NoteModel
    {
        // Attempt to generate a unique UUID for the note by which it can be retrieved from the k-v-store
        $max_uuid_generation_attempts = 10;
        $success = false;
        $UUID = null;
        for ($i = 0; $i < $max_uuid_generation_attempts && !$success; $i++) {
            $UUID = Str::uuid();
            if(!Redis::exists(self::LARAVEL_KEY_PREFIX.$UUID)) {
                $success = true;
            }
        }
        // Throw an error if for some reason this is impossible (has to be a bug, mathematically too unlikely)
        if($success === false) {
            throw new RuntimeException("Could not generate a unique UUID inside of NoteModel::create().");
        }

        $note = new NoteModel($UUID, $email, $content, $tags);

        // Store the note inside the corresponding stores in one atomic transaction
        Facades\Redis::transaction(function ($redis) use ($note) {
            // Store the note itself (as a json_representation) via it's id inside the note store (Our Single Source of Truth)
            $redis->set(self::LARAVEL_KEY_PREFIX.$note->getId(), json_encode($note, JSON_THROW_ON_ERROR));
            // Store the note's id inside the email store via the email
            $redis->sadd(EmailModel::LARAVEL_KEY_PREFIX.$note->getEmail(), $note->getId());
            // Store the note's id inside the tags store via each individual tag
            foreach ($note->tags as $tag) {
                $redis->sadd(TagModel::LARAVEL_KEY_PREFIX.$tag, $note->getId());
            }
        });

        return $note;
    }
}
